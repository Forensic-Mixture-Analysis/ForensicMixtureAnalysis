###READ ME###

Trimming a Matrix of Minimum FSTs

Function: The purpose of this script is to eliminate populations with
the lowest FST values. This script will help to reduce the amount of time
it takes to analyze FST matrices because it eliminates values that are below
a certain threshold. Several functions of this script are: 1) identify if there are duplicates
of the lowest value, and if so, randomly choose one. 2) Identify the
location of the lowest value. 3) Randomly choose an axis (row or column) and 
delete the corresponding numbers of that axis (ex: if the lowest value's index
was [row 4, column 2], this script may randomly choose the column axis and correspondingly
delete the 2nd row and column). 4) It then checks the remaining values to find the
next lowest value and compares it to the threshold; if it is below that threshold,
the loop repeats. 5) When all values are greater than the threshold, it ends by
printing two lists: one with all the deleted populations and one with all the 
populations still in the mix.

###Understanding the Script###

#Setup#
In order to run the script, it must import the random, numpy and csv built in modules.

Make sure to have the correct file paths pasted line 15 and 27. Line 15 is the 
FST matrix file path, and line 27 is the pop names file path.

An FST matrix will be used as an input. The population names list will also be imported
from a separate file. The population names must be in the same order as the FST matrix,
for example, if Afghanistan.1_new is the first population, it must be so in both 
the FST matrix and in the population names list.

The first thing the script does is delete (set to 100) all values that fall on the 
diagonal. This is because this is where populations are being compared to themselves.

Next, it uses len(a) (for simplicity, a is the name of the matrix)
to find the number of rows of the matrix and len(a[0])
to find the number of columns of the matrix (this will be used to create an index later).
It then creates a list with the range of numbers depending on the row and column number.
For example, a 5x5 matrix will have range_of_rows and _range_of_cols be a list: [0, 1, 2, 3, 4]
(This will be used for indexing later).

Next, in order to setup the values, it uses a nested for loop to append all values
from the matrix into an ordered list. Conveniently, this is done in order from the first index
of the matrix all the way to the last.The next step is to create a dictionary with keys of every
index of the matrix. For example, a 5x5 matrix will have 25 keys ((0,0), (0,1), (0,2), (0,3), 
(0,4), (1,0), (1,1), etc.). 

The last part of the setup is to finally create the dictionary. It creates an empty dictionary,
then fills it using a nested for loop. The outer loop refers to the row numbers in the range of
rows while the inner loop refers to the column numbers in the range of columns. Using .keys(),
it generates the keys for the dictionary. Finally, using zip(), it creates the dictionary by
zipping together the keys and values.

#Lowest value#
Using .min(), it finds the lowest values of the matrix. Next, we create a while loop that cycles
until all values in the matrix are above a certain threshold. It will continue to loop as long as
there exists a value in the matrix that is below that threshold. The next step is to identify the
location(s) of the lowest value in the matrix using np.where(). The problem that arises is if there
are multiple of the lowest value. If this happens, it will record all the rows and columns of
each lowest value. For example, if there are lowest values at indices (1, 1) and (3, 2), it will
save the location as [1, 3] [1, 2], which is confusing. 

#Addressing multiple lowest values#
In order to address the issue of multiple lowest values, there is an if statement that checks if
there are more than one recorded row values for the lowest value. If so, it uses rm.sample() in order
to randomly choose one of the row values and delete the rest (and does the same with the corresponding
column values since that will have the same issue). Now that there only one row and column value for
the lowest value, it can used in the next block of code.

#Randomly choosing an axis, and deleting the row and column of the value of the randomly chosen axis#
Using rm.sample(), it randomly chooses either the row or column of the lowest value in the matrix
that is below the minimum value. It then deletes (sets to 100) that specified value on the matrix.
It finds the next lowest value by reusing .min().

#New and updated list and dictionary#
final_FSTarray_values is a new list that is generated by checking all the values in the new matrix.
There's a new list created called fina_values_status to basically append the string "deleted"
for any values that were converted to 100. This way, if one wanted to check the updated matrix,
it will correctly say that value was removed.

A new dictionary is made that has the updated values from the matrix. It then uses .sort() in order
to arrange all the deleted indices, which will match the population list order. Lastly, it uses
enumerate function in order to iterate through the population names list and check if it 
belongs in the deleted populations list or populations still in the matrix. It prints out
both deleted populations and populations still in the matrix at the end of the script.
